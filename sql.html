<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Complete SQL Notes with Subtopics</title>
<style>
    body { font-family: Arial, sans-serif; line-height:1.6; margin:0; padding:0; background:#f9f9f9; }
    header { background:#2c3e50; color:white; padding:20px; text-align:center; }
    nav { background:#34495e; padding:10px; position:sticky; top:0; z-index:1000; }
    nav a { color:white; text-decoration:none; margin-right:15px; font-weight:bold; }
    nav a:hover { text-decoration:underline; }
    section { padding:20px; margin:10px auto; max-width:1000px; background:white; border-radius:8px; box-shadow:0 0 10px rgba(0,0,0,0.1); }
    h2 { color:#2c3e50; border-bottom:2px solid #2980b9; padding-bottom:5px; }
    h3 { color:#2980b9; margin-top:20px; }
    h4 { color:#c0392b; margin-top:15px; }
    p { margin-bottom:10px; }
    pre { background:#ecf0f1; padding:15px; border-radius:5px; overflow-x:auto; }
    code { color:#c0392b; font-weight:bold; }
    footer { text-align:center; padding:15px; background:#2c3e50; color:white; margin-top:20px; }
</style>
</head>
<body>

<header>
    <h1>Complete SQL Notes</h1>
    <p>Detailed explanations, syntax, examples, and subtopics</p>
</header>

<nav>
    <a href="#basics">Relational Database Basics</a>
    <a href="#keys">Primary & Foreign Keys</a>
    <a href="#operators">Operators</a>
    <a href="#clauses">Clauses & Queries</a>
    <a href="#joins">Joins</a>
    <a href="#functions">Functions</a>
    <a href="#transactions">Transactions & ACID</a>
    <a href="#advanced">Advanced Topics</a>
</nav>

<!-- Basics -->
<section id="basics">
    <h2>Relational Database Basics</h2>
    <p>Relational databases store data in tables, which consist of rows (records) and columns (fields). Relationships are established between tables using keys.</p>
    <h3>Subtopics:</h3>
    <h4>Tables and Records</h4>
    <p>A table is a collection of related data, and each row is a record containing data for each column. Each column has a defined datatype.</p>
    <pre><code>CREATE TABLE employees (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    salary DECIMAL(10,2)
);</code></pre>

    <h4>Schema</h4>
    <p>Defines structure of the database, including tables, columns, datatypes, and constraints.</p>
</section>

<!-- Keys -->
<section id="keys">
    <h2>Primary and Foreign Keys</h2>
    <h3>Primary Key</h3>
    <p>Uniquely identifies each record. Cannot be NULL. Only one per table.</p>
    <pre><code>CREATE TABLE employees (
    id INT PRIMARY KEY,
    name VARCHAR(50)
);</code></pre>

    <h3>Foreign Key</h3>
    <p>Links a column in one table to the primary key in another table. Ensures referential integrity.</p>
    <pre><code>CREATE TABLE departments (
    dept_id INT PRIMARY KEY,
    emp_id INT,
    FOREIGN KEY (emp_id) REFERENCES employees(id)
);</code></pre>

    <h3>Subtopics</h3>
    <h4>Composite Key</h4>
    <p>Primary key consisting of multiple columns.</p>
    <pre><code>CREATE TABLE order_items (
    order_id INT,
    item_id INT,
    PRIMARY KEY(order_id, item_id)
);</code></pre>
</section>

<!-- Operators -->
<section id="operators">
    <h2>SQL Operators</h2>
    <p>Operators are used to perform calculations, comparisons, or logical operations.</p>

    <h3>Comparison Operators</h3>
    <p>Used in WHERE clause to filter data. Examples include <code>=, <>, !=, <, >, <=, >=, IS NULL, IS NOT NULL, BETWEEN, IN</code>.</p>
    <pre><code>SELECT * FROM employees WHERE salary >= 50000;
SELECT * FROM employees WHERE dept_id IN (1,2,3);
SELECT * FROM employees WHERE name IS NOT NULL;</code></pre>

    <h3>Logical Operators</h3>
    <p>Combine multiple conditions in queries. Examples: <code>AND, OR, NOT, XOR</code>.</p>
    <pre><code>SELECT * FROM employees WHERE salary > 50000 AND dept_id = 1;
SELECT * FROM employees WHERE NOT salary < 30000;</code></pre>

    <h3>Arithmetic Operators</h3>
    <p>Perform numeric calculations: <code>+, -, *, /, %, MOD, DIV</code>.</p>
    <pre><code>SELECT salary * 0.1 AS bonus FROM employees;
SELECT MOD(salary, 1000) FROM employees;</code></pre>

    <h3>Bitwise Operators</h3>
    <p>Operate on binary representations of numbers: <code>&, |, ^, ~, <<, >></code>.</p>
    <pre><code>SELECT id & 1 FROM employees;</code></pre>

    <h3>String & Search Operators</h3>
    <p>Used to manipulate or search text: <code>||, CONCAT, LIKE, NOT LIKE, ILIKE, SIMILAR TO, REGEXP, RLIKE, ESCAPE</code>.</p>
    <pre><code>SELECT name FROM employees WHERE name LIKE 'J%';
SELECT CONCAT(name, ' works in ', department) FROM employees;</code></pre>

    <h3>Set Operators</h3>
    <p>Combine results of multiple queries: <code>UNION, UNION ALL, INTERSECT, EXCEPT, MINUS</code>.</p>
    <pre><code>SELECT name FROM employees
UNION
SELECT name FROM contractors;</code></pre>
</section>

<!-- Clauses -->
<section id="clauses">
    <h2>Clauses & Queries</h2>
    <p>Clauses define which data to select and how to filter or sort it.</p>

    <h3>SELECT & FROM</h3>
    <p>Select columns and specify tables to retrieve data.</p>
    <pre><code>SELECT name, salary FROM employees;</code></pre>

    <h3>WHERE</h3>
    <p>Filters rows based on condition.</p>
    <pre><code>SELECT * FROM employees WHERE salary > 50000;</code></pre>

    <h3>ORDER BY</h3>
    <p>Sorts results by column(s) ascending/descending.</p>
    <pre><code>SELECT * FROM employees ORDER BY salary DESC;</code></pre>

    <h3>LIMIT / TOP</h3>
    <p>Restricts number of rows returned.</p>
    <pre><code>SELECT * FROM employees LIMIT 5;</code></pre>

    <h3>DISTINCT</h3>
    <p>Removes duplicates in results.</p>
    <pre><code>SELECT DISTINCT dept_id FROM employees;</code></pre>

    <h3>Subqueries & Correlated Subqueries</h3>
    <p>A subquery is a query inside another query. Correlated subquery references outer query values.</p>
    <pre><code>SELECT * FROM employees 
WHERE salary > (SELECT AVG(salary) FROM employees);</code></pre>
</section>

<!-- Joins -->
<section id="joins">
    <h2>Joins</h2>
    <p>Joins combine rows from multiple tables based on related columns.</p>

    <h3>INNER JOIN</h3>
    <p>Returns rows with matching values in both tables.</p>
    <pre><code>SELECT a.name, b.department
FROM employees a
INNER JOIN departments b ON a.id = b.emp_id;</code></pre>

    <h3>LEFT JOIN</h3>
    <p>Returns all rows from left table and matching rows from right table.</p>
    <pre><code>SELECT a.name, b.department
FROM employees a
LEFT JOIN departments b ON a.id = b.emp_id;</code></pre>

    <h3>RIGHT JOIN</h3>
    <p>Returns all rows from right table and matching rows from left table.</p>
    <pre><code>SELECT a.name, b.department
FROM employees a
RIGHT JOIN departments b ON a.id = b.emp_id;</code></pre>

    <h3>FULL OUTER JOIN</h3>
    <p>Returns all rows when there is a match in either table.</p>
    <pre><code>SELECT a.name, b.department
FROM employees a
FULL OUTER JOIN departments b ON a.id = b.emp_id;</code></pre>

    <h3>CROSS JOIN</h3>
    <p>Returns Cartesian product of both tables (all combinations).</p>
    <pre><code>SELECT a.name, b.department
FROM employees a CROSS JOIN departments b;</code></pre>

    <h3>Self Join & Aliases</h3>
    <p>Self join joins a table with itself; aliases help differentiate the table instances.</p>
    <pre><code>SELECT e1.name AS Employee, e2.name AS Manager
FROM employees e1
LEFT JOIN employees e2 ON e1.manager_id = e2.id;</code></pre>
</section>

<!-- Functions -->
<section id="functions">
    <h2>SQL Functions</h2>
    <h3>Aggregate Functions</h3>
    <p>Perform calculations across multiple rows: <code>COUNT, SUM, AVG, MIN, MAX</code>.</p>
    <pre><code>SELECT COUNT(*), SUM(salary), AVG(salary), MIN(salary), MAX(salary) FROM employees;</code></pre>

    <h3>GROUP BY & HAVING</h3>
    <p>GROUP BY aggregates rows; HAVING filters grouped results.</p>
    <pre><code>SELECT dept_id, AVG(salary) 
FROM employees 
GROUP BY dept_id 
HAVING AVG(salary) > 50000;</code></pre>

    <h3>String Functions</h3>
    <p>Manipulate text: CONCAT, LENGTH, UPPER, LOWER, SUBSTRING, TRIM.</p>
    <pre><code>SELECT CONCAT(name, ' works in ', department) FROM employees;
SELECT LENGTH(name) FROM employees;
SELECT UPPER(name) FROM employees;</code></pre>

    <h3>Date Functions</h3>
    <p>Manipulate dates and times: NOW(), CURDATE(), DATE_ADD(), DATE_SUB().</p>
    <pre><code>SELECT NOW();
SELECT DATE_ADD(NOW(), INTERVAL 7 DAY);</code></pre>

    <h3>Window Functions</h3>
    <p>Perform calculations across a set of related rows: ROW_NUMBER, RANK, DENSE_RANK, LEAD, LAG.</p>
    <pre><code>SELECT name, salary, 
ROW_NUMBER() OVER (PARTITION BY dept_id ORDER BY salary DESC) AS rank
FROM employees;</code></pre>

    <h3>CASE Statements</h3>
    <p>Conditional logic in SELECT, can be used like IF-ELSE.</p>
    <pre><code>SELECT name,
CASE 
    WHEN salary > 50000 THEN 'High'
    ELSE 'Low'
END AS SalaryCategory
FROM employees;</code></pre>
</section>

<!-- Transactions & ACID -->
<section id="transactions">
    <h2>Transactions & ACID Properties</h2>
    <p>Transactions are groups of operations treated as a single unit. ACID properties ensure database reliability.</p>
    <ul>
        <li><b>Atomicity:</b> All operations succeed or none.</li>
        <li><b>Consistency:</b> Database remains valid after transaction.</li>
        <li><b>Isolation:</b> Transactions do not interfere with each other.</li>
        <li><b>Durability:</b> Committed changes persist after failures.</li>
    </ul>
    <pre><code>START TRANSACTION;
INSERT INTO employees (id, name, salary) VALUES (10, 'Alice', 70000);
COMMIT;
-- ROLLBACK undoes changes before commit</code></pre>
</section>

<!-- Advanced Topics -->
<section id="advanced">
    <h2>Advanced Topics</h2>
    <h3>Views</h3>
    <p>Virtual tables defined by SELECT queries. Helpful for abstraction and security.</p>
    <pre><code>CREATE VIEW high_salary AS
SELECT * FROM employees WHERE salary > 50000;</code></pre>

    <h3>Stored Procedures</h3>
    <p>Reusable SQL code blocks that can take parameters and perform operations.</p>
    <pre><code>CREATE PROCEDURE GiveBonus(IN empID INT, IN bonusAmount DECIMAL(10,2))
BEGIN
    UPDATE employees SET salary = salary + bonusAmount WHERE id = empID;
END;</code></pre>

    <h3>Triggers</h3>
    <p>Automatic actions executed when table events occur (INSERT, UPDATE, DELETE).</p>
    <pre><code>CREATE TRIGGER after_salary_update
AFTER UPDATE ON employees
FOR EACH ROW
BEGIN
    INSERT INTO audit_log(emp_id, old_salary, new_salary)
    VALUES (OLD.id, OLD.salary, NEW.salary);
END;</code></pre>

    <h3>User-Defined Functions</h3>
    <p>Custom functions returning values, can be reused in queries.</p>
    <pre><code>CREATE FUNCTION get_tax(salary DECIMAL(10,2)) RETURNS DECIMAL(10,2)
BEGIN
    RETURN salary * 0.1;
END;</code></pre>

    <h3>Normalization & Indexing</h3>
    <p>Normalization reduces redundancy (1NF, 2NF, 3NF). Indexing improves query performance.</p>
    <pre><code>CREATE INDEX idx_salary ON employees(salary);</code></pre>
</section>

<footer>
    <p>SQL Notes Â© 2026 | Prepared by Nirbhay Singh</p>
</footer>

</body>
</html>
